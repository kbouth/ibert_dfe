#!/usr/bin/env python3

from jinja2 import Environment, FileSystemLoader, pass_context
import os
from pathlib import Path
import re
import argparse
import itertools
from typing import List


class Hdf:
    """
    Extract metadata from HDF file name
    example: damc_fmc2zup_example_design_mpsoc_0.0.0-30-g1bbef14e-devbranch.xsa

    projname ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    version  ----------------------------------^^^^^
    commits  ----------------------------------------^^
    hash     --------------------------------------------^^^^^^^^
    branch   -----------------------------------------------------^^^^^^^^^

    also available:
    abspath, filename, basename

    These values can then be used in jinja2 template files

    """

    RE_HDFNAME = re.compile(
        r"(?P<projname>.+)[-_][vV]?(?P<version>\d+\.\d+\.\d+)(?P<opt1>-(?P<commits>\d+)-g(?P<hash>[0-9a-f]+))?(?P<opt2>-(?P<branch>.+))?$"
    )

    def __init__(self, path: Path, projdir: Path):
        self.path, self.filename, self.stem = (
            path.relative_to(projdir),
            path.name,
            path.stem,
        )

        match = self.RE_HDFNAME.match(self.stem)
        meta = match.groupdict() if match else None

        for attr in ["projname", "version", "commits", "hash", "branch"]:
            self.__setattr__(attr, meta[attr] if meta and meta[attr] else "")

        self.recipename = self.projname.replace("_", "-")

        # Now try to find associated mapfiles
        mapp = Path(path.parent).glob(f"{self.stem}*.mapp")
        mapt = Path(path.parent).glob(f"{self.stem}*.mapt")

        mapfiles = itertools.chain.from_iterable((mapp, mapt))
        self.mapfiles = sorted(p.relative_to(projdir) for p in mapfiles)

        # And C/C++ header files
        c_hdr = Path(path.parent).glob(f"{self.stem}*.h")
        cpp_hdr = Path(path.parent).glob(f"{self.stem}*.hpp")

        headerfiles = itertools.chain.from_iterable((c_hdr, cpp_hdr))
        self.headerfiles = sorted(p.relative_to(projdir) for p in headerfiles)

    def basename(self, filename: str):
        return os.path.basename(filename).replace(self.stem, self.projname)


class RecipeGen:
    """
    Create Yocto recipes for HDF files by rendering Jinja2 template files
    """

    def __init__(self, args):
        """
        projdir = root dir of FWK project
        layerdir = path to Yocto HDF layer
        """
        self.projdir = args.projdir
        self.layerdir = args.layerdir
        self.projname = args.projname
        self.machine = args.machine
        self.debug = args.debug

    def get_hdf(self, fileglob: str):
        """
        Resolve glob expression, return Hdf object
        """
        files = (Path(self.projdir) / "out").rglob(fileglob)
        # If multiple files are found, use the most recent one
        hdf_path = sorted(files, key=lambda p: p.stat().st_mtime)
        if not len(hdf_path):
            raise RuntimeError(
                f'Could not find any files with glob expression "{fileglob}" - are the HDF files not yet built or downloaded?'
            )
        self.hdf = Hdf(hdf_path[-1], Path(self.projdir))
        return self.hdf

    def get_jinja2_env(self):
        env = Environment(loader=FileSystemLoader([self.projdir, os.path.dirname(__file__)]))
        env.globals.update(
            {
                "fwk_topdir": self.projdir,
                "get_hdf": self.get_hdf,
                "projname": self.projname,
                "machine": self.machine,
            }
        )
        return env

    def autogen_warning(self, srcfile: str):
        # Warning about auto-generated content
        rel_script = Path(__file__).relative_to(self.projdir)
        rel_template = Path(srcfile).relative_to(self.projdir)
        return f"# Autogenerated from {rel_template} by {rel_script}. DO NOT EDIT!\n\n"

    def get_template(self, env, srcfile: str):
        return env.get_template(str(Path(srcfile).relative_to(self.projdir)))

    def process_template(self, srcfile: str):
        """
        Process template file; create recipe from it
        """
        if self.debug:
            print(f"Processing template {srcfile}")

        env = self.get_jinja2_env()
        template = self.get_template(env, srcfile)
        rendered = self.autogen_warning(srcfile) + template.render()

        destfile = re.sub(r"\.jinja2$", "", srcfile)

        # If we're creating a .bb (not .bbappend) then name it according to the HDF project
        if destfile.endswith(".bb"):
            newname = self.hdf.recipename
            if self.hdf.version:
                newname += f"_{self.hdf.version}"
            destfile = os.path.join(os.path.dirname(destfile), f"{newname}.bb")

        open(destfile, "w").write(rendered)
        return self.hdf.recipename if destfile.endswith('bb') else None

    def process_packagegroup(self, srcfile: str, recipes: List[str]):
        """
        Process package group; summarize project's recipes
        """
        if self.debug:
            print(f"Processing packagegroup {srcfile}")

        env = self.get_jinja2_env()
        env.globals["recipes"] = recipes
        template = self.get_template(env, srcfile)
        rendered = self.autogen_warning(srcfile) + template.render()

        pg_name = self.projname.replace("_", "-")
        destfile = os.path.join(os.path.dirname(srcfile), f"packagegroup-{pg_name}-hdf.bb")

        open(destfile, "w").write(rendered)

    def process_layer(self):
        """
        Find jinja2 templates in the layer and process them one by one
        """

        recipes = []
        for p in Path(self.layerdir).rglob("*.jinja2"):
            if p.stem.startswith("packagegroup"):
                continue
            srcfile = str(p)
            recipe = self.process_template(srcfile)
            if recipe:
                recipes.append(recipe)

        for p in Path(self.layerdir).rglob("packagegroup*.jinja2"):
            srcfile = str(p)
            self.process_packagegroup(srcfile, recipes)


def main():
    parser = argparse.ArgumentParser(
        description="Create static recipe(s) from FWK artifacts (HDF and mapfiles)"
    )

    parser.add_argument("-p", "--projdir", type=str, help="project root directory")
    parser.add_argument("-l", "--layerdir", type=str, help="yocto layer directory")
    parser.add_argument("-n", "--projname", type=str, help="name of FWK project")
    parser.add_argument("-m", "--machine", type=str, help="name of MACHINE")
    parser.add_argument("-d", "--debug", action="store_true", help="debug mode")

    args = parser.parse_args()
    RecipeGen(args).process_layer()


if __name__ == "__main__":
    main()
